lang mcore

// Return the last element of a list
let return_last_element = lam x:TySeqInt. (seqmethod.last [Int] x)
utest 0 (return_last_element (newseq [int] (0)))
utest 1 (return_last_element (newseq [int] (0,1)))

// Return the last element but one
let return_last_element_but_one = lam x:TySeqInt. (
  let last_index_but_one = (subi (seqmethod.length [Int] x) 2) in
  seqmethod.nth [Int] x last_index_but_one
)
utest 0 (return_last_element_but_one (newseq [int] (0,1)))
utest 1 (return_last_element_but_one (newseq [int] (0,1,2)))

// Return the nth element
let nth = lam x:TySeqInt. lam n:Int. (seqmethod.nth [Int] x n)
utest 0 (nth (newseq [int] (0,1)) 0)
utest 1 (nth (newseq [int] (0,1)) 1)

// Return the length
let length = lam x:TySeqInt. (seqmethod.length [Int] x)
utest 0 (length (newseq [int] ()))
utest 1 (length (newseq [int] (0)))

// Return the reverse
let reverse = lam x:TySeqInt. (seqmethod.reverse [Int] x)
utest (newseq [int] (3,2,1)) (reverse (newseq [int] (1,2,3)))

// Return palindrome result
let compare_elements = fix (lam compare_elements:(TySeqInt->TySeqInt->Bool). lam seq1:TySeqInt. lam seq2:TySeqInt.
  if (and (seqmethod.is_empty [Int] seq1) (seqmethod.is_empty [Int] seq2)) then
    true
  else if (or (seqmethod.is_empty [Int] seq1) (seqmethod.is_empty [Int] seq2)) then
   false
  else
    if (eqi (seqmethod.first [Int] seq1) (seqmethod.first [Int] seq2)) then
      compare_elements (seqmethod.drop [Int] seq1 1) (seqmethod.drop [Int] seq2 1)
    else
      false
)

let check_if_palindrome = lam x:TySeqInt. (
  let rev_x = seqmethod.reverse [Int] x in
  compare_elements x rev_x
)
utest true (check_if_palindrome (newseq [int] (1,2,3,2,1)))
utest false (check_if_palindrome (newseq [int] (1,2,3)))

// Eliminate consecutive duplicates (TODO)
let eliminate_duplicates_helper = fix (lam eliminate_duplicates_helper:(Int->TySeqInt->TySeqInt->TySeqInt). lam e:Int. lam l:TySeqInt. lam newl:TySeqInt. (
  if (seqmethod.is_empty [Int] l) then
    seqmethod.push_last [Int] newl e
  else (
    let hd = seqmethod.first [Int] l in
    let tl = seqmethod.drop [Int] l 1 in
    if (eqi e hd) then
      eliminate_duplicates_helper e tl newl
    else
      let newl2 = seqmethod.push_last [Int] newl e in
      eliminate_duplicates_helper hd tl newl2
    )
))
let eliminate_duplicates = lam x:TySeqInt. (
  if (seqmethod.is_empty [Int] x) then
    x
  else
    let hd = seqmethod.first [Int] x in
    let tl = seqmethod.drop [Int] x 1 in
    let newl = newseq [int] () in
    eliminate_duplicates_helper hd tl newl
)
utest (newseq [int] (1)) (eliminate_duplicates (newseq [int] (1,1)))
utest (newseq [int] (1,2,3)) (eliminate_duplicates (newseq [int] (1,1,2,3,3)))

// Duplicate elements
let duplicate_list = fix (lam duplicate_list:(TySeqInt->TySeqInt). lam x:TySeqInt.
  if (seqmethod.is_empty [Int] x) then
    newseq [int] ()
  else
    let currhd = seqmethod.first [Int] x in
    let currtl = seqmethod.drop [Int] x 1 in
    let newl = newseq [int] (currhd,currhd) in
    seqmethod.append [Int] (newl) (duplicate_list currtl)
)
utest (newseq [int] (1,1,2,2)) (duplicate_list (newseq [int] (1,2)))

// Replicate elements n times
let createreplicates = fix (lam createreplicates:(Int->Int->TySeqInt->TySeqInt). lam x:Int. lam n:Int. lam newl:TySeqInt. (
  if (eqi n 0) then (
    newl
  ) else (
    let newl2 = seqmethod.push [Int] newl x in
    let newn = subi n 1 in
    createreplicates x newn newl2
  )))
let replicate_elements_n_times_helper = fix (lam replicate_elements_n_times_helper:(TySeqInt->Int->TySeqInt->TySeqInt). lam l:TySeqInt. lam n:Int. lam newl:TySeqInt. (
  if (seqmethod.is_empty [Int] l) then (
    newl
  ) else (
    let hd = seqmethod.first [Int] l in
    let tl = seqmethod.drop [Int] l 1 in
    let nreplicates = createreplicates hd n (newseq [int] ()) in
    let newl2 = seqmethod.append [Int] newl nreplicates in
    replicate_elements_n_times_helper tl n newl2
  )))
let replicate_elements_n_times = lam x:TySeqInt. lam n:Int. (
  if (eqi n 0) then
    (x)
  else
    replicate_elements_n_times_helper x n (newseq [int] ())
)
utest (newseq [int] (1,1,1)) (replicate_elements_n_times (newseq [int] (1)) 3)
utest (newseq [int] (1,1,2,2)) (replicate_elements_n_times (newseq [int] (1,2)) 2)

// Drop every nth element
let drop_nth_element = fix (lam drop_nth_element:(TySeqInt->Int->TySeqInt->Int->TySeqInt). lam l:TySeqInt. lam n:Int. lam newl:TySeqInt. lam i:Int. (
  if (seqmethod.is_empty [Int] l) then (
    newl
  ) else (
    let hd = seqmethod.first [Int] l in
    let tl = seqmethod.drop [Int] l 1 in
    if (eqi i 1) then (
      drop_nth_element tl n newl n
    ) else (
      let newl2 = seqmethod.push_last [Int] newl hd in
      drop_nth_element tl n newl2 (subi i 1)
    )
  )))
  utest (newseq [int] (1,3)) (drop_nth_element (newseq [int] (1,2,3,4)) 2 (newseq [int] ()) 2)
  utest (newseq [int] ()) (drop_nth_element (newseq [int] (1,2,3,4)) 1 (newseq [int] ()) 1)

// Split a list into two parts (at index n), and get the first one
let split_list_get_first_part = lam x:TySeqInt. lam n:Int. (
  seqmethod.take [Int] x n
)
utest (newseq [int] (1,2)) (split_list_get_first_part (newseq [int] (1,2,3,4)) 2)

// Split a list into two parts (at index n), and get the second one
let split_list_get_last_part = lam x:TySeqInt. lam n:Int. (
  seqmethod.drop [Int] x n
)
utest (newseq [int] (3,4)) (split_list_get_last_part (newseq [int] (1,2,3,4)) 2)

// Get a part of the list between indices m and n
let split_list_btw_m_and_n = lam x:TySeqInt. lam m:Int. lam n:Int. (
  let updx1 = seqmethod.drop [Int] x m in
  let newn = subi n m in
  seqmethod.take [Int] updx1 (subi newn 1)
)
utest (newseq [int] (2)) (split_list_btw_m_and_n (newseq [int] (1,2,3)) 1 3)
utest (newseq [int] (1,2)) (split_list_btw_m_and_n (newseq [int] (1,2,3)) 0 3)

// Rotate n places left
let rotate_n_left = lam x:TySeqInt. lam n:Int. (
  let lhs = seqmethod.take [Int] x n in
  let rhs = seqmethod.drop [Int] x n in
  seqmethod.append [Int] rhs lhs
)
utest (newseq [int] (2,3,1)) (rotate_n_left (newseq [int] (1,2,3)) 1)
utest (newseq [int] (3,1,2)) (rotate_n_left (newseq [int] (1,2,3)) 2)

// Remove nth element
let remove_element_n = lam x:TySeqInt. lam n:Int. (
  let lhs = seqmethod.take [Int] x (subi n 1) in
  let rhs = seqmethod.drop [Int] x n in
  seqmethod.append [Int] lhs rhs
)
utest (newseq [int] (1,3)) (remove_element_n (newseq [int] (1,2,3)) 2)
utest (newseq [int] (1,2,3)) (remove_element_n (newseq [int] (1,2,3,4)) 4)

// Filter elements within a given range
let filter_elements_in_range = lam x:TySeqInt. lam m:Int. lam n:Int. (
  seqmethod.filter [Int] (lam x:Int. if (and (lti x n) (gti x m)) then true else false) (newseq [int] (1,2,3))
)
utest (newseq [int] (2)) (filter_elements_in_range (newseq [int] (1,2,3)) 1 3)
